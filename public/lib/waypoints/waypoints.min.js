/*!
Waypoints - 4.0.1
Copyright Â© 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/

(function () {
    "use strict";

    function Waypoint(options) {
        if (!options) {
            throw new Error("No options passed to Waypoint constructor");
        }
        if (!options.element) {
            throw new Error("No element option passed to Waypoint constructor");
        }
        if (!options.handler) {
            throw new Error("No handler option passed to Waypoint constructor");
        }

        this.key = "waypoint-" + waypointIndex;
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options);
        this.element = options.element;
        this.adapter = new Waypoint.Adapter(this.element);
        this.callback = options.handler;
        this.axis = options.horizontal ? "horizontal" : "vertical";
        this.enabled = options.enabled;
        this.triggerPoint = null;
        this.group = Waypoint.Group.findOrCreate({
            name: options.group,
            axis: this.axis,
        });
        this.context = Waypoint.Context.findOrCreateByElement(
            options.context
        );

        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset];
        }

        this.group.add(this);
        this.context.add(this);

        waypoints[this.key] = this;
        waypointIndex += 1;
    }

    var waypointIndex = 0;
    var waypoints = {};

    Waypoint.prototype.queueTrigger = function (direction) {
        this.group.queueTrigger(this, direction);
    };

    Waypoint.prototype.trigger = function (args) {
        if (this.enabled && this.callback) {
            this.callback.apply(this, args);
        }
    };

    Waypoint.prototype.destroy = function () {
        this.context.remove(this);
        this.group.remove(this);
        delete waypoints[this.key];
    };

    Waypoint.prototype.disable = function () {
        this.enabled = false;
        return this;
    };

    Waypoint.prototype.enable = function () {
        this.context.refresh();
        this.enabled = true;
        return this;
    };

    Waypoint.prototype.next = function () {
        return this.group.next(this);
    };

    Waypoint.prototype.previous = function () {
        return this.group.previous(this);
    };

    Waypoint.invokeAll = function (method) {
        var allWaypoints = [];
        for (var waypointKey in waypoints) {
            allWaypoints.push(waypoints[waypointKey]);
        }
        for (var i = 0, len = allWaypoints.length; i < len; i++) {
            allWaypoints[i][method]();
        }
    };

    Waypoint.destroyAll = function () {
        Waypoint.invokeAll("destroy");
    };

    Waypoint.disableAll = function () {
        Waypoint.invokeAll("disable");
    };

    Waypoint.enableAll = function () {
        Waypoint.Context.refreshAll();
        for (var waypointKey in waypoints) {
            waypoints[waypointKey].enabled = true;
        }
        return this;
    };

    Waypoint.refreshAll = function () {
        Waypoint.Context.refreshAll();
    };

    Waypoint.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight;
    };

    Waypoint.viewportWidth = function () {
        return document.documentElement.clientWidth;
    };

    Waypoint.adapters = [];

    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: "default",
        horizontal: false,
        offset: 0,
    };

    Waypoint.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth();
        },
    };

    Waypoint.Adapter = function (element) {
        this.element = element;
    };

    Waypoint.Adapter.prototype = {
        innerHeight: function () {
            if (this.element === window) {
                return Waypoint.viewportHeight();
            }
            return this.element.clientHeight;
        },
        innerWidth: function () {
            if (this.element === window) {
                return Waypoint.viewportWidth();
            }
            return this.element.clientWidth;
        },
        outerHeight: function (includeMargin) {
            var height = this.innerHeight();
            if (includeMargin) {
                var style = window.getComputedStyle(this.element);
                height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
            }
            return height;
        },
        outerWidth: function (includeMargin) {
            var width = this.innerWidth();
            if (includeMargin) {
                var style = window.getComputedStyle(this.element);
                width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
            }
            return width;
        },
        scrollLeft: function () {
            if (this.element === window) {
                return window.pageXOffset;
            }
            return this.element.scrollLeft;
        },
        scrollTop: function () {
            if (this.element === window) {
                return window.pageYOffset;
            }
            return this.element.scrollTop;
        },
        off: function (event, handler) {
            if (this.element.removeEventListener) {
                this.element.removeEventListener(event, handler, false);
            } else if (this.element.detachEvent) {
                this.element.detachEvent("on" + event, handler);
            }
        },
        on: function (event, handler) {
            if (this.element.addEventListener) {
                this.element.addEventListener(event, handler, false);
            } else if (this.element.attachEvent) {
                this.element.attachEvent("on" + event, handler);
            }
        },
        offset: function () {
            if (this.element === window) {
                return { top: 0, left: 0 };
            }
            return this.element.getBoundingClientRect();
        },
    };

    Waypoint.Group = function (options) {
        this.name = options.name;
        this.axis = options.axis;
        this.id = this.name + "-" + this.axis;
        this.waypoints = [];
        this.clearTriggerQueues();
        groups[this.axis][this.name] = this;
    };

    var groups = {
        vertical: {},
        horizontal: {},
    };

    Waypoint.Group.prototype.add = function (waypoint) {
        this.waypoints.push(waypoint);
    };

    Waypoint.Group.prototype.clearTriggerQueues = function () {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: [],
        };
    };

    Waypoint.Group.prototype.flushTriggers = function () {
        for (var direction in this.triggerQueues) {
            var waypoints = this.triggerQueues[direction];
            waypoints.sort(direction === "up" || direction === "left" ? ascSort : descSort);
            for (var i = 0, len = waypoints.length; i < len; i++) {
                var waypoint = waypoints[i];
                if (
                    waypoint.options.continuous ||
                    i === waypoints.length - 1
                ) {
                    waypoint.trigger([direction]);
                }
            }
        }
        this.clearTriggerQueues();
    };

    Waypoint.Group.prototype.next = function (waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        return this.waypoints[index + 1];
    };

    Waypoint.Group.prototype.previous = function (waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        if (index === 0) {
            return null;
        }
        return this.waypoints[index - 1];
    };

    Waypoint.Group.prototype.queueTrigger = function (waypoint, direction) {
        this.triggerQueues[direction].push(waypoint);
    };

    Waypoint.Group.prototype.remove = function (waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        if (index > -1) {
            this.waypoints.splice(index, 1);
        }
    };

    Waypoint.Group.prototype.first = function () {
        return this.waypoints[0];
    };

    Waypoint.Group.prototype.last = function () {
        return this.waypoints[this.waypoints.length - 1];
    };

    Waypoint.Group.findOrCreate = function (options) {
        return groups[options.axis][options.name] || new Waypoint.Group(options);
    };

    Waypoint.Context = function (element) {
        this.element = element;
        this.Adapter = Waypoint.Adapter;
        this.adapter = new this.Adapter(element);
        this.waypoints = [];
        this.scrollTop = this.adapter.scrollTop();
        this.scrollLeft = this.adapter.scrollLeft();
        this.offsets = {
            vertical: [],
            horizontal: [],
        };
        this.triggerPoint = null;
        this.prevScrollTop = null;
        this.prevScrollLeft = null;
        this.refresh();
        Waypoint.Context.add(this);
    };

    Waypoint.Context.prototype.refresh = function () {
        var isWindow = this.element === window;
        var contextOffset = isWindow ? undefined : this.adapter.offset();
        var triggeredGroups = {};

        this.offsets.vertical = [];
        this.offsets.horizontal = [];

        var waypoints = this.waypoints;
        var adapterOffset;
        var elementOffset;
        var direction;
        var i;
        var len;
        var waypoint;
        var oldScrollTop;
        var oldScrollLeft;

        if (contextOffset) {
            this.adapter.scrollLeft(0);
            this.adapter.scrollTop(0);
            oldScrollTop = this.adapter.scrollTop();
            oldScrollLeft = this.adapter.scrollLeft();
        }

        for (i = 0, len = waypoints.length; i < len; i++) {
            waypoint = waypoints[i];
            var waypointElement = waypoint.element;
            var waypointAdapter = this.Adapter.offset(waypointElement);
            var waypointContext = waypoint.contextOffset
                ? this.Adapter.offset(waypoint.contextElement)
                : { top: 0, left: 0 };

            if (typeof waypoint.options.offset === "function") {
                waypointAdapter = waypoint.options.offset.apply(
                    waypoint,
                    [waypointElement, waypointAdapter]
                );
            } else if (typeof waypoint.options.offset === "string") {
                waypointAdapter = waypointContext[
                    waypoint.options.offset
                ] + waypointAdapter;
            }

            if (waypoint.options.axis === "horizontal") {
                adapterOffset = waypointAdapter.left;
                elementOffset = waypointAdapter.left - waypointContext.left;
                direction =
                    waypoint.options.direction === "left" ? -1 : 1;
            } else {
                adapterOffset = waypointAdapter.top;
                elementOffset = waypointAdapter.top - waypointContext.top;
                direction =
                    waypoint.options.direction === "up" ? -1 : 1;
            }

            if (!waypoint.offset) {
                waypoint.offset = {};
            }
            waypoint.offset[waypoint.options.axis] = adapterOffset;
            waypoint.offset[waypoint.options.axis + "1"] = elementOffset * direction;

            if (waypoint.options.group) {
                var group = triggeredGroups[waypoint.options.group];
                if (!group) {
                    group = triggeredGroups[waypoint.options.group] = {
                        horizontal: [],
                        vertical: [],
                    };
                }
                group[waypoint.options.axis].push(waypoint);
            } else {
                this.offsets[waypoint.options.axis].push(waypoint);
            }
        }

        for (var groupKey in triggeredGroups) {
            var group = triggeredGroups[groupKey];
            group.horizontal.sort(function (a, b) {
                return a.offset.left - b.offset.left;
            });
            group.vertical.sort(function (a, b) {
                return a.offset.top - b.offset.top;
            });
            this.offsets.horizontal = this.offsets.horizontal.concat(
                group.horizontal
            );
            this.offsets.vertical = this.offsets.vertical.concat(group.vertical);
        }

        this.offsets.horizontal.sort(function (a, b) {
            return a.offset - b.offset;
        });
        this.offsets.vertical.sort(function (a, b) {
            return a.offset - b.offset;
        });

        if (this.triggerPoint === null) {
            this.triggerPoint = this.adapter.scrollTop();
        }

        if (contextOffset) {
            this.adapter.scrollTop(oldScrollTop);
            this.adapter.scrollLeft(oldScrollLeft);
        }
    };

    Waypoint.Context.prototype.checkEmpty = function () {
        if (
            this.waypoints.length === 0 &&
            !this.adapter.isWindow(this.element)
        ) {
            this.adapter.off("scroll", this.handler);
            delete contexts[this.adapter.toStr(this.element)];
        }
    };

    Waypoint.Context.prototype.scrollHandler = function () {
        var scrollTop =
            this.adapter.scrollTop();
        var scrollLeft =
            this.adapter.scrollLeft();

        var isScrollingUp = scrollTop > this.prevScrollTop;
        var isScrollingDown = scrollTop < this.prevScrollTop;
        var isScrollingLeft = scrollLeft > this.prevScrollLeft;
        var isScrollingRight = scrollLeft < this.prevScrollLeft;

        this.prevScrollTop = scrollTop;
        this.prevScrollLeft = scrollLeft;

        if (
            this.waypoints.length === 0 ||
            (this.prevScrollTop === scrollTop && this.prevScrollLeft === scrollLeft)
        ) {
            return;
        }

        var triggeredGroups = {};
        var axes = {
            vertical: isScrollingDown ? "down" : "up",
            horizontal: isScrollingRight ? "right" : "left",
        };

        for (var axis in axes) {
            var direction = axes[axis];
            var waypoints = this.offsets[axis];
            waypoints.sort(function (a, b) {
                return a.offset - b.offset;
            });

            for (var i = 0, len = waypoints.length; i < len; i++) {
                var waypoint = waypoints[i];
                if (waypoint.triggerPoint === null) {
                    continue;
                }
                var wasBeforeTriggerPoint =
                    this.prevScrollTop <= waypoint.triggerPoint;
                var nowAfterTriggerPoint = scrollTop > waypoint.triggerPoint;
                var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint;
                var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint;
                if (crossedForward || crossedBackward) {
                    waypoint.queueTrigger(direction);
                    triggeredGroups[waypoint.group.id] = waypoint.group;
                }
            }
        }

        for (var groupKey in triggeredGroups) {
            triggeredGroups[groupKey].flushTriggers();
        }
        this.checkEmpty();
    };

    Waypoint.Context.prototype.resizeHandler = function () {
        this.refresh();
    };

    Waypoint.Context.prototype.forceResizeHandler = function () {
        if (contextsWithoutResizeHandler[this.adapter.toStr(this.element)]) {
            this.resizeHandler();
        }
    };

    Waypoint.Context.findOrCreateByElement = function (element) {
        return (
            contexts[this.adapter.toStr(element)] ||
            new Waypoint.Context(element)
        );
    };

    Waypoint.Context.refreshAll = function () {
        for (var contextKey in contexts) {
            contexts[contextKey].refresh();
        }
    };

    Waypoint.Context.handleResizeAll = function () {
        for (var contextName in contexts) {
            contexts[contextName].forceResizeHandler();
        }
    };

    Waypoint.Adapter = {
        extend: function (out) {
            var args = Array.prototype.slice.call(arguments, 1);
            for (var i = 0, len = args.length; i < len; i++) {
                var obj = args[i];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        out[key] = obj[key];
                    }
                }
            }
            return out;
        },
        inArray: function (element, array, i) {
            return array == null ? -1 : array.indexOf(element, i);
        },
        isEmptyObject: function (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
            return true;
        },
        isFunction: function (obj) {
            return typeof obj === "function";
        },
        isArray: Array.isArray || function (obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        },
        noop: function () { },
        toStr: function (obj) {
            return Object.prototype.toString.call(obj);
        },
    };

    window.Waypoint = Waypoint;

})();
